import{_ as s,c as a,d as n,j as l,a as e,e as o,L as p,o as t}from"./app.81d9e70c.js";const c='{"title":"Reactivity Fundamentals","description":"","frontmatter":{"outline":"deep"},"headers":[{"level":2,"title":"Declaring Reactive State","slug":"declaring-reactive-state"},{"level":2,"title":"반응형 상태 선언하기","slug":"반응형-상태-선언하기"},{"level":3,"title":"Reactive Proxy vs. Original","slug":"reactive-proxy-vs-original","optionsOnly":true},{"level":3,"title":"반응형 프락시 vs 원본","slug":"반응형-프락시-vs-원본","optionsOnly":true},{"level":3,"title":"<script setup>","slug":"script-setup","compositionOnly":true},{"level":2,"title":"Declaring Methods","slug":"declaring-methods","optionsOnly":true},{"level":2,"title":"메소드 선언","slug":"메소드-선언","optionsOnly":true},{"level":3,"title":"DOM Update Timing","slug":"dom-update-timing"},{"level":3,"title":"DOM 갱신 타이밍","slug":"dom-갱신-타이밍"},{"level":3,"title":"Deep Reactivity","slug":"deep-reactivity"},{"level":3,"title":"깊은(Deep) 반응형","slug":"깊은-deep-반응형"},{"level":3,"title":"Reactive Proxy vs. Original","slug":"reactive-proxy-vs-original-1","compositionOnly":true},{"level":3,"title":"반응형 프락시 vs 원본","slug":"반응형-프락시-vs-원본-1","compositionOnly":true},{"level":3,"title":"Limitations of reactive()","slug":"limitations-of-reactive","compositionOnly":true},{"level":3,"title":"reactive()의 제약 사항","slug":"reactive-의-제약-사항","compositionOnly":true},{"level":2,"title":"Reactive Variables with ref()","slug":"reactive-variables-with-ref","compositionOnly":true},{"level":2,"title":"ref()를 이용한 반응형 변수","slug":"ref-를-이용한-반응형-변수","compositionOnly":true},{"level":3,"title":"Ref Unwrapping in Templates","slug":"ref-unwrapping-in-templates","compositionOnly":true},{"level":3,"title":"템플릿에서 ref는 언래핑됩니다.","slug":"템플릿에서-ref는-언래핑됩니다","compositionOnly":true},{"level":3,"title":"Ref Unwrapping in Reactive Objects","slug":"ref-unwrapping-in-reactive-objects","compositionOnly":true},{"level":3,"title":"반응형 객체의 Ref 언래핑","slug":"반응형-객체의-ref-언래핑","compositionOnly":true},{"level":3,"title":"Stateful Methods","slug":"stateful-methods","optionsOnly":true},{"level":3,"title":"상태를 가지는 메소드","slug":"상태를-가지는-메소드","optionsOnly":true},{"level":2,"title":"Reactivity Transform","slug":"reactivity-transform","compositionOnly":true},{"level":2,"title":"반응형 변환","slug":"반응형-변환","compositionOnly":true}],"relativePath":"guide/essentials/reactivity-fundamentals.md"}',r={},i=e('<div class="warning custom-block"><p class="custom-block-title">현재 이 문서는 번역 작업이 진행중입니다</p></div><h1 id="reactivity-fundamentals" tabindex="-1">Reactivity Fundamentals <a class="header-anchor" href="#reactivity-fundamentals" aria-hidden="true">#</a></h1><h1 id="반응형-기초" tabindex="-1">반응형 기초 <a class="header-anchor" href="#반응형-기초" aria-hidden="true">#</a></h1><div class="tip custom-block"><p class="custom-block-title">API Preference</p><p>This page and many other chapters later in the guide contain different content for Options API and Composition API. Your current preference is <span class="options-api">Options API</span><span class="composition-api">Composition API</span>. You can toggle between the API styles using the &quot;API Preference&quot; switches at the top of the left sidebar.</p></div><div class="tip custom-block"><p class="custom-block-title">API Preference</p><p>이 페이지와 가이드 뒷부분의 다른 많은 장에는 옵션 API 및 컴포지션 API에 대한 다양한 콘텐츠가 포함되어 있습니다. 현재 설정은 <span class="options-api">옵션 API</span><span class="composition-api">컴포지션 API</span>입니다. 왼쪽 사이드바 상단에 있는 &quot;API 기본 설정&quot; 스위치를 사용하여 API 스타일을 전환할 수 있습니다.</p></div><h2 id="declaring-reactive-state" tabindex="-1">Declaring Reactive State <a class="header-anchor" href="#declaring-reactive-state" aria-hidden="true">#</a></h2><h2 id="반응형-상태-선언하기" tabindex="-1">반응형 상태 선언하기 <a class="header-anchor" href="#반응형-상태-선언하기" aria-hidden="true">#</a></h2><div class="options-api"><p>With Options API, we use the <code>data</code> option to declare reactive state of a component. The option value should be a function that returns an object. Vue will call the function when creating a new component instance, and wrap the returned object in its reactivity system. Any top-level properties of this object are proxied on the component instance (<code>this</code> in methods and lifecycle hooks):</p><p>Options API에서는 <code>data</code> 옵션을 사용하여 컴포넌트의 반응 상태를 선언합니다. 옵션 값은 객체를 반환하는 함수여야 합니다. Vue는 새 컴포넌트 인스턴스를 만들 때마다 해당 함수를 호출하여 반환된 개체를 반응성 시스템에 래핑합니다. 반환된 객체의 모든 최상위 속성은 컴포넌트 인스턴스에서 프록시됩니다(메서드 및 생명주기 후크에서 <code>this</code>로 접근 할 수 있습니다).</p><div class="language-js"><div class="highlight-lines"><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">data</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">      count</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// `mounted` is a lifecycle hook which we will explain later</span></span>\n<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// `mounted`는 생명주기 후크인데 나중에 설명합니다. </span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">mounted</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// `this` refers to the component instance.</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// `this` 는 컴포넌트 인스턴스를 나타냅니다. </span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">count</span><span style="color:#F07178;">) </span><span style="color:#676E95;font-style:italic;">// =&gt; 1</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// data can be mutated as well</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 데이터는 잘 변경됩니다.</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">count</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><p><a href="https://sfc.vuejs.org/#eyJBcHAudnVlIjoiPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY291bnQ6IDFcbiAgICB9XG4gIH0sXG5cbiAgLy8gYG1vdW50ZWRgIGlzIGEgbGlmZWN5Y2xlIGhvb2sgd2hpY2ggd2Ugd2lsbCBleHBsYWluIGxhdGVyXG4gIG1vdW50ZWQoKSB7XG4gICAgLy8gYHRoaXNgIHJlZmVycyB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLlxuICAgIGNvbnNvbGUubG9nKHRoaXMuY291bnQpIC8vID0+IDFcblxuICAgIC8vIGRhdGEgY2FuIGJlIG11dGF0ZWQgYXMgd2VsbFxuICAgIHRoaXMuY291bnQgPSAyXG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48dGVtcGxhdGU+XG4gIENvdW50IGlzOiB7eyBjb3VudCB9fVxuPC90ZW1wbGF0ZT4iLCJpbXBvcnQtbWFwLmpzb24iOiJ7XG4gIFwiaW1wb3J0c1wiOiB7XG4gICAgXCJ2dWVcIjogXCJodHRwczovL3NmYy52dWVqcy5vcmcvdnVlLnJ1bnRpbWUuZXNtLWJyb3dzZXIuanNcIlxuICB9XG59In0=" target="_blank" rel="noopener noreferrer">Try it in the Playground</a></p><p>These instance properties are only added when the instance is first created, so you need to ensure they are all present in the object returned by the <code>data</code> function. Where necessary, use <code>null</code>, <code>undefined</code> or some other placeholder value for properties where the desired value isn&#39;t yet available.</p><p>이러한 인스턴스 속성은 인스턴스가 처음 생성될 때만 추가되므로 <code>data</code> 함수에서 반환된 객체에 필요한 속성이 모두 존재하는지 확인해야 합니다. 필요한 경우 <code>null</code>, <code>undefined</code> 또는 원하는 값을 아직 사용할 수 없는 속성에 대해 임시 값(PLaceholder value)을 사용하세요.</p><p>It is possible to add a new property directly to <code>this</code> without including it in <code>data</code>. However, properties added this way will not be able to trigger reactive updates.</p><p><code>data</code>에 포함하지 않고 <code>this</code>에 직접 새 속성을 추가할 수 있습니다. 그러나 이러한 방식으로 추가된 속성은 반응형 업데이트를 트리거할 수 없습니다.</p><p>Vue uses a <code>$</code> prefix when exposing its own built-in APIs via the component instance. It also reserves the prefix <code>_</code> for internal properties. You should avoid using names for top-level <code>data</code> properties that start with either of these characters.</p><p>Vue는 컴포넌트 인스턴스를 통해 자체 내장 API를 노출할 때 <code>$</code> 접두사를 사용합니다. 또한 내부 속성에 대해 접두사 <code>_</code>를 예약합니다. 이러한 문자 중 하나로 시작하는 최상위 <code>data</code> 속성의 이름을 사용하지 않아야 합니다.</p><h3 id="reactive-proxy-vs-original" tabindex="-1">Reactive Proxy vs. Original <a class="header-anchor" href="#reactive-proxy-vs-original" aria-hidden="true">#</a></h3><h3 id="반응형-프락시-vs-원본" tabindex="-1">반응형 프락시 vs 원본 <a class="header-anchor" href="#반응형-프락시-vs-원본" aria-hidden="true">#</a></h3><p>In Vue 3, data is made reactive by leveraging <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">JavaScript Proxies</a>. Users coming from Vue 2 should be aware of the following edge case:</p><p>Vue 3에서 <code>data</code>는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">JavaScript Proxies</a>를 활용하여 반응형으로 만들어집니다. Vue 2를 사용하다 오시는 분은 다음과 같은 경우에 주의해야 합니다.</p><div class="language-js"><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">data</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">      someObject</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{}</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">mounted</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newObject</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{}</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">someObject</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">newObject</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">newObject</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">someObject</span><span style="color:#F07178;">) </span><span style="color:#676E95;font-style:italic;">// false</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><p>When you access <code>this.someObject</code> after assigning it, the value is a reactive proxy of the original <code>newObject</code>. <strong>Unlike in Vue 2, the original <code>newObject</code> is left intact and will not be made reactive: make sure to always access reactive state as a property of <code>this</code>.</strong></p><p>할당 후 <code>this.someObject</code>에 접근할때 얻어지는 값은 원본 <code>newObject</code>에 대한 반응형 프록시입니다. <strong>Vue 2와 달리 원래의 <code>newObject</code>는 그대로 유지되며 반응형이 되지 않습니다. 항상 <code>this</code>의 속성으로 반응형 상태에 액세스해야 합니다.</strong></p></div><div class="composition-api"><p>We can create a reactive object or array with the <a href="/api/reactivity-core.html#reactive"><code>reactive()</code></a> function:</p><p><a href="/api/reactivity-core.html#reactive"><code>reactive()</code></a> 함수를 사용하여 반응형 객체 또는 배열을 만들 수 있습니다.</p><div class="language-js"><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">reactive</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> state </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">count</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span></code></pre></div><p>Reactive objects are <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">JavaScript Proxies</a> and behave just like normal objects. The difference is that Vue is able to track the property access and mutations of a reactive object. If you are curious about the details, we explain how Vue&#39;s reactivity system works in <a href="/guide/extras/reactivity-in-depth.html">Reactivity in Depth</a> - but we recommend reading it after you have finished the main guide.</p><p>반응형 객체는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">자바스크립트 프락시</a>이며 일반 개체처럼 동작합니다. 보통의 객체와의 차이점은 반응형 객체의 속성을 읽고 변경하는 것을 Vue가 추적할수 있다는 것입니다. <a href="/guide/extras/reactivity-in-depth.html">반응형 심화</a> 가이드에서 Vue의 반응형 시스템이 어떻게 작동하는지 자세히 설명 합니다만, 메인 가이드를 마친후에 읽을 것을 권장합니다.</p><p>See also: <a href="/guide/typescript/composition-api.html#typing-reactive">Typing Reactive</a> <sup class="vt-badge ts"></sup></p><p>참조: <a href="/guide/typescript/composition-api.html#typing-reactive">반응형에 타입 지정하기</a> <sup class="vt-badge ts"></sup></p><p>To use reactive state in a component&#39;s template, declare and return them from a component&#39;s <code>setup()</code> function:</p><p>컴포넌트의 템플릿에서 반응형 상태를 사용하려면 컴포넌트의 <code>setup()</code> 함수에서 이를 선언하고 반환합니다.</p><div class="language-js"><div class="highlight-lines"><br><br><br><br><div class="highlighted"> </div><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br></div><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">reactive</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// `setup` is a special hook dedicated for composition API.</span></span>\n<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// `setup`는 컴포지션 API를 위한 전용 후크입니다. </span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">setup</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> count</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// expose the state to the template</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// state를 템플릿에 노출 시킵니다. </span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">state</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><div class="language-vue-html"><pre><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;{{</span><span style="color:#A6ACCD;"> state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count </span><span style="color:#89DDFF;">}}&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"></span></code></pre></div><p>Similarly, we can declare functions that mutate reactive state in the same scope, and expose it as a method alongside the state:</p><p>마찬가지로 동일한 범위에서 반응형 상태를 변경하는 함수를 선언하고, 상태와 함께 메서드로 노출할 수 있습니다:</p><div class="language-js"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br></div><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">reactive</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">setup</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> count</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">++</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// don&#39;t forget to expose the function as well.</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 함수를 노출하는것을 잊지 마세요</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">,</span></span>\n<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">increment</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><p>Exposed methods are typically used as event listeners:</p><p>노출된 메서드는 일반적으로 이벤트 리스너로 사용됩니다:</p><div class="language-vue-html"><pre><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> @</span><span style="color:#C792EA;">click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">increment</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">{{</span><span style="color:#A6ACCD;"> state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count </span><span style="color:#89DDFF;">}}</span></span>\n<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"></span></code></pre></div><h3 id="script-setup" tabindex="-1"><code>&lt;script setup&gt;</code> <a class="header-anchor" href="#script-setup" aria-hidden="true">#</a></h3><p>Manually exposing state and methods via <code>setup()</code> can be verbose. Luckily, it is only necessary when not using a build step. When using Single-File Components (SFCs), we can greatly simplify the usage with <code>&lt;script setup&gt;</code>:</p><p><code>setup()</code>을 통해 상태와 메서드를 수동으로 노출하는 것은 장황할 수 있습니다. 빌드 도구를 이용해 빌드를 할때는 더 쉬운 방법이 있습니다. SFC(싱글 파일 컴포넌트)를 사용할 때 <code>&lt;script setup&gt;</code>으로 반응형 상태의 사용을 크게 단순화할 수 있습니다:</p><div class="language-vue"><pre><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">setup</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">reactive</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> state </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">count</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">++</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> @</span><span style="color:#C792EA;">click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">increment</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">{{</span><span style="color:#A6ACCD;"> state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count </span><span style="color:#89DDFF;">}}</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"></span></code></pre></div><p><a href="https://sfc.vuejs.org/#eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IHJlYWN0aXZlIH0gZnJvbSAndnVlJ1xuXG5jb25zdCBzdGF0ZSA9IHJlYWN0aXZlKHsgY291bnQ6IDAgfSlcblxuZnVuY3Rpb24gaW5jcmVtZW50KCkge1xuICBzdGF0ZS5jb3VudCsrXG59XG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8YnV0dG9uIEBjbGljaz1cImluY3JlbWVudFwiPlxuICAgIHt7IHN0YXRlLmNvdW50IH19XG4gIDwvYnV0dG9uPlxuPC90ZW1wbGF0ZT4iLCJpbXBvcnQtbWFwLmpzb24iOiJ7XG4gIFwiaW1wb3J0c1wiOiB7XG4gICAgXCJ2dWVcIjogXCJodHRwczovL3NmYy52dWVqcy5vcmcvdnVlLnJ1bnRpbWUuZXNtLWJyb3dzZXIuanNcIlxuICB9XG59In0=" target="_blank" rel="noopener noreferrer">Try it in the Playground</a></p><p>Top-level imports and variables declared in <code>&lt;script setup&gt;</code> are automatically usable in the template of the same component.</p><p>최상위 레벨에서 import 되거나 선언된 변수들은 같은 컴포넌트의 템플릿에 자동으로 노출 되어 사용할수 있습니다.</p><blockquote><p>For the rest of the guide, we will be primarily using SFC + <code>&lt;script setup&gt;</code> syntax for Composition API code examples, as that is the most common usage for Vue developers.</p></blockquote><blockquote><p>이후 가이드 문서의 컴포지션 API 코드 예제에 Vue 개발자들이 가장 많이 사용하는 SFC + <code>&lt;script setup&gt;</code> 문법을 사용할 것입니다.</p></blockquote></div>',9),y={class:"options-api"},D=n("h2",{id:"declaring-methods",tabindex:"-1"},[o("Declaring Methods "),n("a",{class:"header-anchor",href:"#declaring-methods","aria-hidden":"true"},"#")],-1),F=n("h2",{id:"메소드-선언",tabindex:"-1"},[o("메소드 선언 "),n("a",{class:"header-anchor",href:"#메소드-선언","aria-hidden":"true"},"#")],-1),d=e('<p>To add methods to a component instance we use the <code>methods</code> option. This should be an object containing the desired methods:</p><p>컴포넌트 인스턴스에 메소드를 추가하기 위해 <code>methods</code> 옵션을 사용합니다. 이 옵션은 원하는 메소드를 포함하는 객체여야 합니다:</p><div class="language-js"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br><br><br></div><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">data</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">      count</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">methods</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">increment</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">++</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">mounted</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// methods can be called in lifecycle hooks, or other methods!</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 생명주기 후크나 다른 메소드에서 메소드들을 호출할수 있습니다. </span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#82AAFF;">increment</span><span style="color:#F07178;">()</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><p>Vue automatically binds the <code>this</code> value for <code>methods</code> so that it always refers to the component instance. This ensures that a method retains the correct <code>this</code> value if it&#39;s used as an event listener or callback. You should avoid using arrow functions when defining <code>methods</code>, as that prevents Vue from binding the appropriate <code>this</code> value:</p><p>Vue는 항상 컴포넌트 인스턴스를 참조하도록 <code>methods</code>에 대해 <code>this</code> 값을 자동으로 바인딩합니다. 이렇게 하면 메서드가 이벤트 리스너 또는 콜백으로 사용되는 경우 올바른 <code>this</code> 값이 유지됩니다. <code>methods</code>를 정의할때 화살표 함수를 사용하면 Vue가 적절한 <code>this</code> 값을 바인딩 할수 없기 때문에 화살표 함수는 사용하지 말아야 합니다:</p><div class="language-js"><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">methods</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// BAD: no `this` access here!</span></span>\n<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// BAD: `this`에 대해 접근할수 없습니다!</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><p>Just like all other properties of the component instance, the <code>methods</code> are accessible from within the component&#39;s template. Inside a template they are most commonly used as event listeners:</p><p>컴포넌트 인스턴스의 다른 모든 속성과 마찬가지로 <code>methods</code>는 컴포넌트 템플릿 내에서 액세스할 수 있습니다. 템플릿 내에서 이벤트 리스너로 가장 일반적으로 사용됩니다.</p><div class="language-vue-html"><pre><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> @</span><span style="color:#C792EA;">click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">increment</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;{{</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">}}&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"></span></code></pre></div><p><a href="https://sfc.vuejs.org/#eyJBcHAudnVlIjoiPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY291bnQ6IDBcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBpbmNyZW1lbnQoKSB7XG4gICAgICB0aGlzLmNvdW50KytcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5pbmNyZW1lbnQoKVxuICB9XG59XG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8YnV0dG9uIEBjbGljaz1cImluY3JlbWVudFwiPnt7IGNvdW50IH19PC9idXR0b24+XG48L3RlbXBsYXRlPiIsImltcG9ydC1tYXAuanNvbiI6IntcbiAgXCJpbXBvcnRzXCI6IHtcbiAgICBcInZ1ZVwiOiBcImh0dHBzOi8vc2ZjLnZ1ZWpzLm9yZy92dWUucnVudGltZS5lc20tYnJvd3Nlci5qc1wiXG4gIH1cbn0ifQ==" target="_blank" rel="noopener noreferrer">Try it in the Playground</a></p><p>In the example above, the method <code>increment</code> will be called when the <code>&lt;button&gt;</code> is clicked.</p><p>위의 예에서 <code>&lt;button&gt;</code>을 클릭하면 <code>increment</code> 메소드가 호출됩니다.</p>',12),A=e('<h3 id="dom-update-timing" tabindex="-1">DOM Update Timing <a class="header-anchor" href="#dom-update-timing" aria-hidden="true">#</a></h3><h3 id="dom-갱신-타이밍" tabindex="-1">DOM 갱신 타이밍 <a class="header-anchor" href="#dom-갱신-타이밍" aria-hidden="true">#</a></h3><p>When you mutate reactive state, the DOM is updated automatically. However, it should be noted that the DOM updates are not applied synchronously. Instead, Vue buffers them until the &quot;next tick&quot; in the update cycle to ensure that each component needs to update only once no matter how many state changes you have made.</p><p>반응형 상태를 변경하면 DOM이 자동으로 업데이트됩니다. 그러나 DOM 업데이트는 동기적으로 반영되지 않는다는 점에 유의해야 합니다. 대신 Vue는 업데이트 주기의 &quot;다음 틱(tick)&quot;까지 버퍼링하여 상태 변경을 아주 많이 수행했어도 각 컴포넌트가 한 번만 업데이트되도록 합니다.</p><p>To wait for the DOM update to complete after a state change, you can use the <a href="/api/general.html#nexttick">nextTick()</a> global API:</p><p>상태 변경 후 DOM 업데이트가 완료될 때까지 기다리려면 <a href="/api/general.html#nexttick">nextTick()</a> 전역 API를 사용할 수 있습니다:</p><div class="composition-api"><div class="language-js"><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">nextTick</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">++</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">nextTick</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// access updated DOM</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 갱신된 DOM 에 접근 할수 있습니다</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div></div><div class="options-api"><div class="language-js"><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">nextTick</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">methods</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">increment</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">++</span></span>\n<span class="line"><span style="color:#F07178;">      </span><span style="color:#82AAFF;">nextTick</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// access updated DOM</span></span>\n<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 갱신된 DOM 에 접근 할수 있습니다</span></span>\n<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div></div><h3 id="deep-reactivity" tabindex="-1">Deep Reactivity <a class="header-anchor" href="#deep-reactivity" aria-hidden="true">#</a></h3><h3 id="깊은-deep-반응형" tabindex="-1">깊은(Deep) 반응형 <a class="header-anchor" href="#깊은-deep-반응형" aria-hidden="true">#</a></h3><p>In Vue, state is deeply reactive by default. This means you can expect changes to be detected even when you mutate nested objects or arrays:</p><p>Vue에서 상태는 기본적으로 깊게(deep) 반응성을 추적 됩니다. 즉, 중첩된 객체나 배열을 변경하는 경우에도 변경 사항이 감지될 것으로 기대할수 있습니다.</p><div class="options-api"><div class="language-js"><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">data</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">      obj</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">        nested</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> count</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">},</span></span>\n<span class="line"><span style="color:#F07178;">        arr</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> [</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">foo</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">bar</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">]</span></span>\n<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">methods</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">mutateDeeply</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// these will work as expected.</span></span>\n<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// 다음도 기대대로 동작합니다. </span></span>\n<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">nested</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">++</span></span>\n<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">arr</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">baz</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div></div><div class="composition-api"><div class="language-js"><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">reactive</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">nested</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">count</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">},</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">arr</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">foo</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">bar</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">]</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">mutateDeeply</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// these will work as expected.</span></span>\n<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 다음도 기대대로 동작합니다. </span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">nested</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">++</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">arr</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">baz</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div></div><p>It is also possible to explicitly create <a href="/api/reactivity-advanced.html#shallowreactive">shallow reactive objects</a> where the reactivity is only tracked at the root-level, however they are typically only needed in advanced use cases.</p><p>반응성이 루트 수준에서만 추적되는 <a href="/api/reactivity-advanced.html#shallowreactive">얕은 반응 개체</a>(shallow)를 명시적으로 생성하는 것도 가능하지만 일반적으로 고급 사용 사례에서만 필요합니다.</p><div class="composition-api"><h3 id="reactive-proxy-vs-original-1" tabindex="-1">Reactive Proxy vs. Original <a class="header-anchor" href="#reactive-proxy-vs-original-1" aria-hidden="true">#</a></h3><h3 id="반응형-프락시-vs-원본-1" tabindex="-1">반응형 프락시 vs 원본 <a class="header-anchor" href="#반응형-프락시-vs-원본-1" aria-hidden="true">#</a></h3><p>It is important to note that the returned value from <code>reactive()</code> is a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">Proxy</a> of the original object, which is not equal to the original object:</p><p><code>reactive()</code>에서 반환된 값은 원본의 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener noreferrer">Proxy</a>이며 원본 객체를 수정한게 아닙니다. 원본 객체와는 별개의 객체입니다.</p><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> raw </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>\n<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proxy </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(raw)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// proxy is NOT equal to the original.</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// proxy 는 원본과 동일한 객체 인스턴스가 아닙니다. </span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(proxy </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> raw) </span><span style="color:#676E95;font-style:italic;">// false</span></span>\n<span class="line"></span></code></pre></div><p>Only the proxy is reactive - mutating the original object will not trigger updates. Therefore, the best practice when working with Vue&#39;s reactivity system is to <strong>exclusively use the proxied versions of your state</strong>.</p><p>프록시만 반응적입니다. 원본 개체를 변경해도 업데이트가 트리거되지 않습니다. 따라서 Vue의 반응성 시스템으로 작업할 때 가장 좋은 방법은 <strong>상태의 프록시 버전만 독점적으로 사용</strong>하는 것입니다.</p><p>To ensure consistent access to the proxy, calling <code>reactive()</code> on the same object always returns the same proxy, and calling <code>reactive()</code> on an existing proxy also returns that same proxy:</p><p>프록시에 대한 일관된 액세스를 보장하기 위해 동일한 객체에서 <code>reactive()</code>를 호출하면 항상 동일한 프록시가 반환되고 기존 프록시에서 <code>reactive()</code>를 호출해도 동일한 프록시가 반환됩니다.</p><div class="language-js"><pre><code><span class="line"><span style="color:#676E95;font-style:italic;">// calling reactive() on the same object returns the same proxy</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// 동일한 객체에 대해 reactive()를 호출하면 동일한 프락시가 반환됩니다. </span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(raw) </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> proxy) </span><span style="color:#676E95;font-style:italic;">// true</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// calling reactive() on a proxy returns itself</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// 프락시에 대해  reactive()를 호출하면 프락시 자체가 반환됩니다. </span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(proxy) </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> proxy) </span><span style="color:#676E95;font-style:italic;">// true</span></span>\n<span class="line"></span></code></pre></div><p>This rule applies to nested objects as well. Due to deep reactivity, nested objects inside a reactive object are also proxies:</p><p>이 규칙은 중첩된 개체에도 적용됩니다. 깊은 반응성으로 인해 반응성 객체 내부의 중첩 객체도 프록시입니다:</p><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> proxy </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{}</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> raw </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>\n<span class="line"><span style="color:#A6ACCD;">proxy</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">nested </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> raw</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(proxy</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">nested </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> raw) </span><span style="color:#676E95;font-style:italic;">// false</span></span>\n<span class="line"></span></code></pre></div><h3 id="limitations-of-reactive" tabindex="-1">Limitations of <code>reactive()</code> <a class="header-anchor" href="#limitations-of-reactive" aria-hidden="true">#</a></h3><h3 id="reactive-의-제약-사항" tabindex="-1"><code>reactive()</code>의 제약 사항 <a class="header-anchor" href="#reactive-의-제약-사항" aria-hidden="true">#</a></h3><p>The <code>reactive()</code> API has two limitations: <code>reactive()</code> API는 두개의 제약 사항이 있습니다:</p><ol><li><p>It only works for object types (objects, arrays, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#keyed_collections" target="_blank" rel="noopener noreferrer">collection types</a> such as <code>Map</code> and <code>Set</code>). It cannot hold <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" target="_blank" rel="noopener noreferrer">primitive types</a> such as <code>string</code>, <code>number</code> or <code>boolean</code>.</p></li><li><p>객체 유형(객체, 배열 및 <code>Map</code>이나 <code>Set</code>같은 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#keyed_collections" target="_blank" rel="noopener noreferrer">컬렉션 유형</a> )에서만 작동합니다. <code>string</code>, <code>number</code> 또는 <code>boolean</code>과 같은 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" target="_blank" rel="noopener noreferrer">기본 유형</a>에서는 동작하지 않습니다.</p></li><li><p>Since Vue&#39;s reactivity tracking works over property access, we must always keep the same reference to the reactive object. This means we can&#39;t easily &quot;replace&quot; a reactive object because the reactivity connection to the first reference is lost:</p></li><li><p>Vue의 반응 추적은 속성 접근에 대해서만 동작하기 때문에 반응형 개체에 대한 동일한 레퍼런스를 항상 유지해야 합니다. 이것은 첫 번째 레퍼런스에 대한 반응성 연결이 손실되기 때문에 반응성 객체를 쉽게 &quot;교체&quot;할 수 없음을 의미합니다.</p><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> state </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">count</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// the above reference ({ count: 0 }) is no longer being tracked (reactivity connection is lost!)</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// 위에서 생성한 ({ count: 0 }) 에 대한 레퍼런스는 더이상 추적되지 않습니다(반응성 연결을 잃게 됩니다!)</span></span>\n<span class="line"><span style="color:#A6ACCD;">state </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">count</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span></code></pre></div><p>It also means that when we assign or destructure a reactive object&#39;s property into local variables, or when we pass that property into a function, we will lose the reactivity connection:</p><p>그것은 또한 우리가 반응성 객체의 속성을 지역 변수에 할당하거나 구조해체(destructure)를 시도 할 때, 또는 속성만 다른 함수에 전달할 때 반응성 연결을 잃게 된다는 것을 의미합니다:</p><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> state </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">count</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// n is a local variable that is disconnected</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// from state.count.</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// n는 state.count로 부터 연결 해제된 지역 변수입니다. </span></span>\n<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> n </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// does not affect original state</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// 변경해도 원래 상태에 반영되지 않습니다 </span></span>\n<span class="line"><span style="color:#A6ACCD;">n</span><span style="color:#89DDFF;">++</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// count is also disconnected from state.count.</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// ncount는 state.count로 부터 연결 해제되었습니다. </span></span>\n<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> state</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// does not affect original state</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// 변경해도 원래 상태에 반영되지 않습니다 </span></span>\n<span class="line"><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">++</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// the function receives a plain number and</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// won&#39;t be able to track changes to state.count</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// 함수는 그냥 일반 숫자를 인자로 받았을 뿐이고, state.count가 변경되어도 이를 따라갈수 없습니다</span></span>\n<span class="line"><span style="color:#82AAFF;">callSomeFunction</span><span style="color:#A6ACCD;">(state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count)</span></span>\n<span class="line"></span></code></pre></div></li></ol><h2 id="reactive-variables-with-ref" tabindex="-1">Reactive Variables with <code>ref()</code> <a class="header-anchor" href="#reactive-variables-with-ref" aria-hidden="true">#</a></h2><h2 id="ref-를-이용한-반응형-변수" tabindex="-1"><code>ref()</code>를 이용한 반응형 변수 <a class="header-anchor" href="#ref-를-이용한-반응형-변수" aria-hidden="true">#</a></h2><p>To address the limitations of <code>reactive()</code>, Vue also provides a <a href="/api/reactivity-core.html#ref"><code>ref()</code></a> function which allows us to create reactive <strong>&quot;refs&quot;</strong> that can hold any value type:</p><p>이러한 <code>reactive()</code>의 제한 사항을 해소하기 위해, Vue는 어떤 값도 담을수 있는 반응형 <strong>&quot;refs&quot;</strong>(레퍼런스)를 생성하는 <a href="/api/reactivity-core.html#ref"><code>ref()</code></a> 함수를 제공합니다.</p><div class="language-js"><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ref</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span></code></pre></div><p><code>ref()</code> takes the argument and returns it wrapped within a ref object with a <code>.value</code> property:</p><p><code>ref()</code> 는 주거진 인자를 <code>.value</code> 속성으로 감싸는 참조 객체를 반환합니다. :</p><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(count) </span><span style="color:#676E95;font-style:italic;">// { value: 0 }</span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(count</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value) </span><span style="color:#676E95;font-style:italic;">// 0</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">++</span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(count</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value) </span><span style="color:#676E95;font-style:italic;">// 1</span></span>\n<span class="line"></span></code></pre></div><p>See also: <a href="/guide/typescript/composition-api.html#typing-ref">Typing Refs</a> <sup class="vt-badge ts"></sup></p><p>참조: <a href="/guide/typescript/composition-api.html#typing-ref">Refs 에 타입 지정하기</a> <sup class="vt-badge ts"></sup></p><p>Similar to properties on a reactive object, the <code>.value</code> property of a ref is reactive. In addition, when holding object types, ref automatically converts its <code>.value</code> with <code>reactive()</code>.</p><p>반응형 객체의 속성과 유사하게 ref의 <code>.value</code> 속성은 반응형입니다. 또한 ref는 값으로 객체 유형을 가질때 <code>.value</code> 를 <code>reactive()</code> 로 자동으로 변환합니다.</p><p>A ref containing an object value can reactively replace the entire object:</p><p>객체 값을 포함하는 ref는 전체 객체를 반응적으로 교체 할 수 있습니다:</p><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> objectRef </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">count</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// this works reactively</span></span>\n<span class="line"><span style="color:#A6ACCD;">objectRef</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">count</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><p>Refs can also be passed into functions or destructured from plain objects without losing reactivity:</p><p>Ref는 반응성을 잃지 않고 함수로 전달되거나 일반 객체로 구조 해제될 수 있습니다.</p><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">,</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">bar</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// the function receives a ref</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// it needs to access the value via .value but it</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// will retain the reactivity connection</span></span>\n<span class="line"><span style="color:#82AAFF;">callSomeFunction</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// still reactive</span></span>\n<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> foo</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> bar </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> obj</span></span>\n<span class="line"></span></code></pre></div><p>In other words, <code>ref()</code> allows us to create a &quot;reference&quot; to any value and pass it around without losing reactivity. This capability is quite important as it is frequently used when extracting logic into <a href="/guide/reusability/composables.html">Composable Functions</a>.</p><p>즉, <code>ref()</code>를 사용하면 모든 값에 대한 &quot;참조&quot;를 만들고 반응성을 잃지 않고 전달할 수 있습니다. 이 기능은 <a href="/guide/reusability/composables.html">Composable Functions</a>로 로직을 추출할 때 자주 사용되기 때문에 상당히 중요합니다.</p><h3 id="ref-unwrapping-in-templates" tabindex="-1">Ref Unwrapping in Templates <a class="header-anchor" href="#ref-unwrapping-in-templates" aria-hidden="true">#</a></h3><h3 id="템플릿에서-ref는-언래핑됩니다" tabindex="-1">템플릿에서 ref는 언래핑됩니다. <a class="header-anchor" href="#템플릿에서-ref는-언래핑됩니다" aria-hidden="true">#</a></h3><p>When refs are accessed as top-level properties in the template, they are automatically &quot;unwrapped&quot; so there is no need to use <code>.value</code>. Here&#39;s the previous counter example, using <code>ref()</code> instead:</p><p>ref가 템플릿의 최상위 속성으로 액세스되면 자동으로 &quot;래핑 해제&quot;되므로 <code>.value</code>를 사용할 필요가 없습니다. 이전 카운터 예제를 <code>ref()</code>를 이용해 구현해 보았습니다:</p><div class="language-vue"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br></div><pre><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">setup</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ref</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">vue</span><span style="color:#89DDFF;">&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#89DDFF;">++</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> @</span><span style="color:#C792EA;">click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">increment</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">{{</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">}}</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">&lt;!-- no .value needed --&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"></span></code></pre></div><p><a href="https://sfc.vuejs.org/#eyJBcHAudnVlIjoiPHNjcmlwdCBzZXR1cD5cbmltcG9ydCB7IHJlZiB9IGZyb20gJ3Z1ZSdcblxuY29uc3QgY291bnQgPSByZWYoMClcblxuZnVuY3Rpb24gaW5jcmVtZW50KCkge1xuICBjb3VudC52YWx1ZSsrXG59XG48L3NjcmlwdD5cblxuPHRlbXBsYXRlPlxuICA8YnV0dG9uIEBjbGljaz1cImluY3JlbWVudFwiPnt7IGNvdW50IH19PC9idXR0b24+XG48L3RlbXBsYXRlPiIsImltcG9ydC1tYXAuanNvbiI6IntcbiAgXCJpbXBvcnRzXCI6IHtcbiAgICBcInZ1ZVwiOiBcImh0dHBzOi8vc2ZjLnZ1ZWpzLm9yZy92dWUucnVudGltZS5lc20tYnJvd3Nlci5qc1wiXG4gIH1cbn0ifQ==" target="_blank" rel="noopener noreferrer">Try it in the Playground</a></p><p>Note the unwrapping only applies if the ref is a top-level property on the template render context. As an example, <code>foo</code> is a top-level property, but <code>object.foo</code> is not.</p><p>언래핑은 ref가 템플릿 렌더 컨텍스트의 최상위 속성인 경우에만 적용됩니다. 예를 들어 <code>foo</code>는 최상위 속성이지만 <code>object.foo</code>는 그렇지 않습니다.</p><p>So given the following object:</p><p>그래서 다음과 같은 객체가 있을때:</p><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> object </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">foo</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><p>The following expression will <strong>NOT</strong> work as expected:</p><p>다음 표현식은 기대대로 동작하지 <strong>않습니다</strong>:</p><div class="language-vue-html"><pre><code><span class="line"><span style="color:#89DDFF;">{{</span><span style="color:#A6ACCD;"> object</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}}</span></span>\n<span class="line"></span></code></pre></div><p>The rendered result will be <code>[object Object]</code> because <code>object.foo</code> is a ref object. We can fix that by making <code>foo</code> a top-level property:</p><p><code>object.foo</code>는 ref 객체이기 때문에 렌더링된 결과는 <code>[object Object]</code>가 됩니다. <code>foo</code>를 최상위 속성으로 만들어 해결할 수 있습니다.</p><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> foo </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> object</span></span>\n<span class="line"></span></code></pre></div><div class="language-vue-html"><pre><code><span class="line"><span style="color:#89DDFF;">{{</span><span style="color:#A6ACCD;"> foo </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}}</span></span>\n<span class="line"></span></code></pre></div><p>Now the render result will be <code>2</code>.</p><p>이제 렌더링 결과는 <code>2</code>가 됩니다.</p><p>One thing to note is that a ref will also be unwrapped if it is the final evaluated value of a text interpolation (i.e. a <code>{{ }}</code> tag), so the following will render <code>1</code>:</p><p>한 가지 주의할 점은 ref가 텍스트 보간(예: <code>{{ }}</code> 태그)의 최종 평가 값인 경우는 래핑이 해제되므로 다음은 <code>1</code>이 렌더링 됩니다:</p><div class="language-vue-html"><pre><code><span class="line"><span style="color:#89DDFF;">{{</span><span style="color:#A6ACCD;"> object</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">foo </span><span style="color:#89DDFF;">}}</span></span>\n<span class="line"></span></code></pre></div><p>This is just a convenience feature of text interpolation and is equivalent to <code>{{ object.foo.value }}</code>.</p><p>이것은 텍스트 보간의 편의 기능일 뿐이며 <code>{{ object.foo.value }}</code>와 동일합니다.</p><h3 id="ref-unwrapping-in-reactive-objects" tabindex="-1">Ref Unwrapping in Reactive Objects <a class="header-anchor" href="#ref-unwrapping-in-reactive-objects" aria-hidden="true">#</a></h3><h3 id="반응형-객체의-ref-언래핑" tabindex="-1">반응형 객체의 Ref 언래핑 <a class="header-anchor" href="#반응형-객체의-ref-언래핑" aria-hidden="true">#</a></h3><p>When a <code>ref</code> is accessed or mutated as a property of a reactive object, it is also automatically unwrapped so it behaves like a normal property:</p><p><code>ref</code>가 반응 객체의 속성으로 액세스되거나 변경되면 자동으로 래핑 해제되어 일반 속성처럼 작동합니다:</p><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> state </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">  count</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count) </span><span style="color:#676E95;font-style:italic;">// 0</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(count</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value) </span><span style="color:#676E95;font-style:italic;">// 1</span></span>\n<span class="line"></span></code></pre></div><p>If a new ref is assigned to a property linked to an existing ref, it will replace the old ref:</p><p>기존 참조에 연결된 속성에 새 참조가 할당되면 이전 참조를 대체합니다:</p><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> otherCount </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> otherCount</span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count) </span><span style="color:#676E95;font-style:italic;">// 2</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// original ref is now disconnected from state.count</span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(count</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value) </span><span style="color:#676E95;font-style:italic;">// 1</span></span>\n<span class="line"></span></code></pre></div><p>Ref unwrapping only happens when nested inside a deep reactive object. It does not apply when it is accessed as a property of a <a href="/api/reactivity-advanced.html#shallowreactive">shallow reactive object</a>.</p><p>참조 언래핑은 깊은 반응 객체 내부에 중첩된 경우에만 발생합니다. <a href="/api/reactivity-advanced.html#shallowreactive">얕은 반응 객체</a>의 속성으로 접근하는 경우에는 적용되지 않습니다.</p><h4 id="ref-unwrapping-in-arrays-and-collections" tabindex="-1">Ref Unwrapping in Arrays and Collections <a class="header-anchor" href="#ref-unwrapping-in-arrays-and-collections" aria-hidden="true">#</a></h4><h4 id="배열-및-컬렉션의-참조-언래핑" tabindex="-1">배열 및 컬렉션의 참조 언래핑 <a class="header-anchor" href="#배열-및-컬렉션의-참조-언래핑" aria-hidden="true">#</a></h4><p>Unlike reactive objects, there is no unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like <code>Map</code>:</p><p>반응형 객체와 달리 ref가 반응형 배열의 요소로 액세스되거나 <code>Map</code>과 같은 기본 컬렉션 유형으로 액세스될 때 래핑 해제가 수행되지 않습니다.</p><div class="language-js"><pre><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> books </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">([</span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Vue 3 Guide</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)])</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// need .value here</span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(books[</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">]</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> map </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">reactive</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Map</span><span style="color:#A6ACCD;">([[</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">count</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)]]))</span></span>\n<span class="line"><span style="color:#676E95;font-style:italic;">// need .value here</span></span>\n<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(map</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">count</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value)</span></span>\n<span class="line"></span></code></pre></div></div><div class="options-api"><h3 id="stateful-methods" tabindex="-1">Stateful Methods <a class="header-anchor" href="#stateful-methods" aria-hidden="true">#</a></h3><h3 id="상태를-가지는-메소드" tabindex="-1">상태를 가지는 메소드 <a class="header-anchor" href="#상태를-가지는-메소드" aria-hidden="true">#</a></h3><p>In some cases, we may need to dynamically create a method function, for example creating a debounced event handler:</p><p>어떤 경우에는 메소드 함수를 동적으로 생성해야 할 수도 있습니다. 예) 디바운스된 이벤트 핸들러 생성:</p><div class="language-js"><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">debounce</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">lodash-es</span><span style="color:#89DDFF;">&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">methods</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// Debouncing with Lodash</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">click</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">debounce</span><span style="color:#A6ACCD;">(</span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ... respond to click ...</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">500</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div><p>However, this approach is problematic for components that are reused because a debounced function is <strong>stateful</strong>: it maintains some internal state on the elapsed time. If multiple component instances share the same debounced function, they will interfere with one another.</p><p>그러나 이 접근 방식은 디바운스 기능이 시간 경과에 대한 내부 <strong>상태를 가지기</strong> 때문에 재사용되는 컴포넌트에 문제가 있습니다. 여러 컴포넌트 인스턴스가 동일한 디바운스 기능을 공유하는 경우 서로 간섭합니다.</p><p>To keep each component instance&#39;s debounced function independent of the others, we can create the debounced version in the <code>created</code> lifecycle hook:</p><p>각 컴포넌트 인스턴스의 디바운스 기능을 다른 인스턴스와 독립적으로 유지하기 위해 <code>created</code> 수명 주기 후크에서 디바운스된 버전을 만들 수 있습니다.</p><div class="language-js"><pre><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">created</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// each instance now has its own copy of debounced handler</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 각 인스턴스는 자기만의 디바운스 핸들러를 가집니다. </span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">debouncedClick</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">_</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">debounce</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">click</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">500</span><span style="color:#F07178;">)</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">unmounted</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// also a good idea to cancel the timer</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// when the component is removed</span></span>\n<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 컴포넌트가 제거될때 타이머를 캔슬하는것은 좋은 생각이죠. </span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">debouncedClick</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">cancel</span><span style="color:#F07178;">()</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">methods</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">click</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// ... respond to click ...</span></span>\n<span class="line"><span style="color:#89DDFF;">      </span><span style="color:#676E95;font-style:italic;">// 클릭에 응답합니다...</span></span>\n<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"></span></code></pre></div></div><div class="composition-api"><h2 id="reactivity-transform" tabindex="-1">Reactivity Transform <sup class="vt-badge experimental"></sup> <a class="header-anchor" href="#reactivity-transform" aria-hidden="true">#</a></h2><h2 id="반응형-변환" tabindex="-1">반응형 변환 <sup class="vt-badge experimental"></sup> <a class="header-anchor" href="#반응형-변환" aria-hidden="true">#</a></h2><p>Having to use <code>.value</code> with refs is a drawback imposed by the language constraints of JavaScript. However, with compile-time transforms we can improve the ergonomics by automatically appending <code>.value</code> in appropriate locations. Vue provides a compile-time transform that allows us to write the earlier &quot;counter&quot; example like this:</p><p>refs와 함께 <code>.value</code>를 사용해야 하는 것은 JavaScript의 언어 제약으로 인한 제한 사항입니다. 그러나 컴파일 타임 변환을 사용하면 적절한 위치에 <code>.value</code>를 자동으로 추가하여 개발자 편의성을 개선할 수 있습니다. Vue는 다음과 같이 이전 &quot;카운터&quot; 예제를 작성할 수 있는 컴파일 타임 변환을 제공합니다.</p><div class="language-vue"><pre><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">script</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">setup</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">$ref</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">increment</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>\n<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// no need for .value</span></span>\n<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">++</span></span>\n<span class="line"><span style="color:#89DDFF;">}</span></span>\n<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">script</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> @</span><span style="color:#C792EA;">click</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">increment</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;{{</span><span style="color:#A6ACCD;"> count </span><span style="color:#89DDFF;">}}&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>\n<span class="line"></span></code></pre></div><p>You can learn more about <a href="/guide/extras/reactivity-transform.html">Reactivity Transform</a> in its dedicated section. Do note that it is currently still experimental and may change before being finalized.</p><p><a href="/guide/extras/reactivity-transform.html">Reactivity Transform</a>에 대해 자세히 알아볼 수 있습니다. 현재 아직 실험 단계이며 최종 결정되기 전에 변경될 수 있습니다.</p></div>',19);var C=s(r,[["render",function(s,e,o,c,r,C){const u=p("VueSchoolLink");return t(),a("div",null,[i,n("div",y,[D,F,l(u,{href:"https://vueschool.io/lessons/methods-in-vue-3",title:"Free Vue.js Methods Lesson"}),d]),A])}]]);export{c as __pageData,C as default};
